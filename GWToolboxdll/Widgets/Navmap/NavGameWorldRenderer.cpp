#include "stdafx.h"
#include "NavGameWorldRenderer.h"

#include <GWCA/GameEntities/Camera.h>
#include <GWCA/Managers/CameraMgr.h>
#include <Defines.h>
#include <ImGuiAddons.h>
#include <Color.h>

// Note: these two files are autogenerated by CMake!
#include "Shaders/nav_vs.h"
#include "Shaders/nav_ps.h"

bool NavGameWorldRenderer::SetD3DTransform(IDirect3DDevice9* device, const NavmeshBuildSettings& nbs)
{
    if (device == nullptr) {
        return false;
    }

    const auto scale_ = DirectX::XMMatrixScaling(nbs.scale, nbs.scale, nbs.scale);
    const auto rotate_ = DirectX::XMMatrixRotationX(-DirectX::XM_PIDIV2);
    
    const auto cam = GW::CameraMgr::GetCamera();
    const DirectX::XMFLOAT3 eye_pos = {cam->position.x, cam->position.y, cam->position.z};
    const DirectX::XMFLOAT3 player_pos = {cam->look_at_target.x, cam->look_at_target.y, cam->look_at_target.z};
    constexpr DirectX::XMFLOAT3 up = {0.0f, 0.0f, -1.0f};
    
    auto mat_view = DirectX::XMMatrixLookAtLH(XMLoadFloat3(&eye_pos), XMLoadFloat3(&player_pos), XMLoadFloat3(&up));
        
    const auto fov = GW::Render::GetFieldOfView();
    const auto aspect_ratio = static_cast<float>(GW::Render::GetViewportWidth()) / static_cast<float>(GW::Render::GetViewportHeight());

    
    auto mat_proj = DirectX::XMMatrixPerspectiveFovLH(fov, aspect_ratio, 0.1f, 1000000.0f);
    auto wvp = XMMatrixTranspose(scale_ * rotate_ * mat_view * mat_proj);
    
    if (device->SetVertexShaderConstantF(0, reinterpret_cast<const float*>(&wvp), 4) != D3D_OK) {
        Log::Error("NavGameWorldRenderer: unable to SetVertexShaderConstantF(projection), aborting render.");
        return false;
    }

    return true;
}

extern volatile bool navmesh_building;
NavGameWorldRenderer * navgwr = nullptr;

void NavGameWorldRenderer::Render(IDirect3DDevice9* device, Navmesh * nm, const NavmeshBuildSettings& nbs)
{
    if(navmesh_building || !nm || !nm->geom || !nm->sample)return;

    if (need_configure_pipeline) {
        if (!ConfigureProgrammablePipeline(device)) {
            return;
        }
    }

    if (vshader == nullptr || device->SetVertexShader(vshader) != D3D_OK) {
        Log::Error("NavGameWorldRenderer: unable to SetVertexShader, aborting render.");
        return;
    }
    if (pshader == nullptr || device->SetPixelShader(pshader) != D3D_OK) {
        Log::Error("NavGameWorldRenderer: unable to SetPixelShader, aborting render.");
        return;
    }
    if (device->SetVertexDeclaration(vertex_declaration) != D3D_OK) {
        Log::Error("NavGameWorldRenderer: unable to SetVertexShader declaration, aborting render.");
        return;
    }

    // backup original immediate state and transforms:
    DWORD old_D3DRS_SCISSORTESTENABLE = 0;
    DWORD old_D3DRS_STENCILENABLE = 0;
    device->GetRenderState(D3DRS_SCISSORTESTENABLE, &old_D3DRS_SCISSORTESTENABLE);
    device->GetRenderState(D3DRS_STENCILENABLE, &old_D3DRS_STENCILENABLE);

    // no scissor test / stencil
    device->SetRenderState(D3DRS_SCISSORTESTENABLE, 0u);
    device->SetRenderState(D3DRS_STENCILENABLE, 0u);

    if (SetD3DTransform(device, nbs)) {
        //const GW::Camera* cam = GW::CameraMgr::GetCamera();
        // set Pixel Shader constants. they are always expressed as Float4 here:
        // first is the player's position

        //constexpr auto pixel_shader_cur_pos_offset = 0u;
        //constexpr auto pixel_shader_max_dist_offset = 1u;
        //constexpr auto pixel_shader_fog_starts_at_offset = 2u;

        //const float cur_pos_constant[4] = {cam->look_at_target.x, cam->look_at_target.y, cam->look_at_target.z, 0.0f};
        //if (device->SetPixelShaderConstantF(pixel_shader_cur_pos_offset, cur_pos_constant, 1) != D3D_OK) {
            //Log::Error("NavGameWorldRenderer: unable to SetPixelShaderConstantF#0, aborting render.");
            //return;
        //}

        // second is the render max distance
        //const float max_dist_constant[4] = {render_max_distance, 0.0f, 0.0f, 0.0f};
        //if (device->SetPixelShaderConstantF(pixel_shader_max_dist_offset, max_dist_constant, 1) != D3D_OK) {
            //Log::Error("NavGameWorldRenderer: unable to SetPixelShaderConstantF#1, aborting render.");
            //return;
        //}

        // third is the fog constant
        //const float fog_starts_at_constant[4] = {render_max_distance - render_max_distance * fog_factor, 0.0f, 0.0f, 0.0f};
        //if (device->SetPixelShaderConstantF(pixel_shader_fog_starts_at_offset, fog_starts_at_constant, 1) != D3D_OK) {
            //Log::Error("NavGameWorldRenderer: unable to SetPixelShaderConstantF#2, aborting render.");
            //return;
        //}

        dx9_device = device;
        navgwr = this;
        nm->Render();
    }

    // restore immediate state:
    device->SetRenderState(D3DRS_SCISSORTESTENABLE, old_D3DRS_SCISSORTESTENABLE);
    device->SetRenderState(D3DRS_STENCILENABLE, old_D3DRS_STENCILENABLE);
}

bool NavGameWorldRenderer::ConfigureProgrammablePipeline(IDirect3DDevice9* device)
{
    constexpr D3DVERTEXELEMENT9 decl[] = {{0, 0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0}, {0, 12, D3DDECLTYPE_D3DCOLOR, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR, 0}, D3DDECL_END()};
    if (device->CreateVertexDeclaration(decl, &vertex_declaration) != D3D_OK) {
        Log::Error("NavGameWorldRenderer: unable to CreateVertexDeclaration");
        return false;
    }

    if (device->CreateVertexShader(reinterpret_cast<const DWORD*>(&g_vs20_main), &vshader) != D3D_OK) {
        Log::Error("NavGameWorldRenderer: unable to CreateVertexShader");
        return false;
    }
    if (device->CreatePixelShader(reinterpret_cast<const DWORD*>(&g_ps20_main), &pshader) != D3D_OK) {
        Log::Error("NavGameWorldRenderer: unable to CreateVertexShader");
        return false;
    }
    need_configure_pipeline = false;
    return true;
}

void NavGameWorldRenderer::LoadSettings(const ToolboxIni* ini, const char* section)
{
    render_navmesh = ini->GetBoolValue(section, VAR_NAME(render_navmesh), render_navmesh);
}

void NavGameWorldRenderer::SaveSettings(ToolboxIni* ini, const char* section)
{
    ini->SetBoolValue(section, VAR_NAME(render_navmesh), render_navmesh);
}

void NavGameWorldRenderer::DrawSettings()
{
    static const auto red = ImGui::ColorConvertU32ToFloat4(Colors::Red());
    ImGui::TextColored(red, "Warning: This is a beta feature and will render over your character, game props, and UI elements.");
    
    ImGui::Checkbox("Render navmesh", &render_navmesh);
    ImGui::ShowHelp("This should only be used for debugging during the pathfinding beta.");
}
