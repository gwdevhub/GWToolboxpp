#include "stdafx.h"

#include "NavMarkerRenderer.h"

#include <Widgets/Minimap/D3DVertex.h>

// Note: these two files are autogenerated by CMake!
#include "Shaders/nav_marker_vs.h"
#include "Shaders/nav_marker_ps.h"

#define color_portal_default 0xFF999999
#define color_teleporter_default 0xFF999999
#define color_primary_objective_default 0xFF999999
#define color_secondary_objective_default 0xFF999999

void NavMarkerRenderer::LoadSettings(const ToolboxIni* ini, const char* section)
{
    color_portal = Colors::Load(ini, section, "color_portal", color_portal_default);
    color_teleporter = Colors::Load(ini, section, "color_teleporter", color_teleporter_default);
    color_primary_objective = Colors::Load(ini, section, "color_primary_objective", color_primary_objective_default);
    color_secondary_objective = Colors::Load(ini, section, "color_secondary_objective", color_secondary_objective_default);
    Invalidate();
}

void NavMarkerRenderer::SaveSettings(ToolboxIni* ini, const char* section) const
{
    Colors::Save(ini, section, "color_portal", color_portal);
    Colors::Save(ini, section, "color_teleporter", color_teleporter);
    Colors::Save(ini, section, "color_primary_objective", color_primary_objective);
    Colors::Save(ini, section, "color_secondary_objective", color_secondary_objective);
}

void NavMarkerRenderer::DrawSettings()
{
    bool confirm = false;
    if (ImGui::SmallConfirmButton("Restore Defaults", &confirm)) {
        color_portal = color_portal_default;
        color_teleporter = color_teleporter_default;
        color_primary_objective = color_primary_objective_default;
        color_secondary_objective = color_secondary_objective_default;
        Invalidate();
    }
    if (Colors::DrawSettingHueWheel("Portal", &color_portal)) {
        Invalidate();
    }
    if (Colors::DrawSettingHueWheel("Teleporter", &color_teleporter)) {
        Invalidate();
    }
    if (Colors::DrawSettingHueWheel("Primary Objective", &color_primary_objective)) {
        Invalidate();
    }
    if (Colors::DrawSettingHueWheel("Secondary Objective", &color_secondary_objective)) {
        Invalidate();
    }
}

void NavMarkerRenderer::Initialize(IDirect3DDevice9* device)
{
    segments = 36;
    angleIncrement = 2.0f * DirectX::XM_PI / segments;
    vertexCount = segments + 2;

    NavmapUIvertex * vertices = nullptr;

    // allocate new vertex buffer
    if (buffer) {
        buffer->Release();
    }
    device->CreateVertexBuffer(sizeof(NavmapUIvertex) * vertexCount, D3DUSAGE_WRITEONLY,
                               D3DFVF_NAVMAP_UI_VERTEX, D3DPOOL_MANAGED, &buffer, nullptr);
    buffer->Lock(0, sizeof(NavmapUIvertex) * vertexCount,
                 reinterpret_cast<void**>(&vertices), D3DLOCK_DISCARD);

    NavmapUIvertex* vertices_begin = vertices;

    type = D3DPT_TRIANGLEFAN;

    vertices[0].x = 0.0f;
    vertices[0].y = 0.0f;
    vertices[0].z = 0.0f;

    const float radius = 250.0f;

    for(int i = 1; i < vertexCount; ++i)
    {
        float angle = angleIncrement * (i - 1);
        vertices[i].x = radius * cosf(angle);
        vertices[i].y = radius * sinf(angle);
        vertices[i].z = 0.0f;
    }

    buffer->Unlock();
}

void NavMarkerRenderer::Render(IDirect3DDevice9* device)
{
    if (!initialized) {
        initialized = true;
        Initialize(device);
    }

    if (need_configure_pipeline) {
        if (!ConfigureProgrammablePipeline(device)) {
            return;
        }
    }

    if (vshader == nullptr || device->SetVertexShader(vshader) != D3D_OK) {
        Log::Error("NavGameWorldRenderer: unable to SetVertexShader, aborting render.");
        return;
    }
    if (pshader == nullptr || device->SetPixelShader(pshader) != D3D_OK) {
        Log::Error("NavGameWorldRenderer: unable to SetPixelShader, aborting render.");
        return;
    }
    if (device->SetVertexDeclaration(vertex_declaration) != D3D_OK) {
        Log::Error("NavGameWorldRenderer: unable to SetVertexShader declaration, aborting render.");
        return;
    }

    // backup original immediate state and transforms:
    DWORD old_D3DRS_SCISSORTESTENABLE = 0;
    DWORD old_D3DRS_STENCILENABLE = 0;
    device->GetRenderState(D3DRS_SCISSORTESTENABLE, &old_D3DRS_SCISSORTESTENABLE);
    device->GetRenderState(D3DRS_STENCILENABLE, &old_D3DRS_STENCILENABLE);

    // no scissor test / stencil (used by minimap)
    device->SetRenderState(D3DRS_SCISSORTESTENABLE, 0u);
    device->SetRenderState(D3DRS_STENCILENABLE, 0u);

    if (SetD3DTransform(device, nbs)) {
        //const GW::Camera* cam = GW::CameraMgr::GetCamera();
        // set Pixel Shader constants. they are always expressed as Float4 here:
        // first is the player's position

        //constexpr auto pixel_shader_cur_pos_offset = 0u;
        //constexpr auto pixel_shader_max_dist_offset = 1u;
        //constexpr auto pixel_shader_fog_starts_at_offset = 2u;

        //const float cur_pos_constant[4] = {cam->look_at_target.x, cam->look_at_target.y, cam->look_at_target.z, 0.0f};
        //if (device->SetPixelShaderConstantF(pixel_shader_cur_pos_offset, cur_pos_constant, 1) != D3D_OK) {
            //Log::Error("NavGameWorldRenderer: unable to SetPixelShaderConstantF#0, aborting render.");
            //return;
        //}

        // second is the render max distance
        //const float max_dist_constant[4] = {render_max_distance, 0.0f, 0.0f, 0.0f};
        //if (device->SetPixelShaderConstantF(pixel_shader_max_dist_offset, max_dist_constant, 1) != D3D_OK) {
            //Log::Error("NavGameWorldRenderer: unable to SetPixelShaderConstantF#1, aborting render.");
            //return;
        //}

        // third is the fog constant
        //const float fog_starts_at_constant[4] = {render_max_distance - render_max_distance * fog_factor, 0.0f, 0.0f, 0.0f};
        //if (device->SetPixelShaderConstantF(pixel_shader_fog_starts_at_offset, fog_starts_at_constant, 1) != D3D_OK) {
            //Log::Error("NavGameWorldRenderer: unable to SetPixelShaderConstantF#2, aborting render.");
            //return;
        //}

        dx9_device = device;
        navgwr = this;
        nm->Render();
    }

    // restore immediate state:
    device->SetRenderState(D3DRS_SCISSORTESTENABLE, old_D3DRS_SCISSORTESTENABLE);
    device->SetRenderState(D3DRS_STENCILENABLE, old_D3DRS_STENCILENABLE);

    device->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, segments);

        //D3DMATRIX oldview;
        //device->GetTransform(D3DTS_VIEW, &oldview);
        //const auto oldMatrix = XMLoadFloat4x4(reinterpret_cast<const DirectX::XMFLOAT4X4*>(&oldview));
        //const auto translate = DirectX::XMMatrixTranslation(0, -50, 0.0f); //TODO: scale
        //const auto newview = oldMatrix * translate;
        //device->SetTransform(D3DTS_VIEW, reinterpret_cast<const D3DMATRIX*>(&newview));

        //device->SetFVF(D3DFVF_CUSTOMVERTEX);
        //device->SetStreamSource(0, buffer, 0, sizeof(D3DVertex));
        //device->DrawPrimitive(type, 0, tri_count_);

        //device->SetTransform(D3DTS_VIEW, &oldview);

        //device->DrawPrimitive(type, vert_count_, tri_count_);
}

bool NavGameWorldRenderer::ConfigureProgrammablePipeline(IDirect3DDevice9* device)
{
    constexpr D3DVERTEXELEMENT9 decl[] = {{0, 0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0}, {0, 12, D3DDECLTYPE_D3DCOLOR, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR, 0}, D3DDECL_END()};
    if (device->CreateVertexDeclaration(decl, &vertex_declaration) != D3D_OK) {
        Log::Error("NavGameWorldRenderer: unable to CreateVertexDeclaration");
        return false;
    }

    if (device->CreateVertexShader(reinterpret_cast<const DWORD*>(&g_vs20_main), &vshader) != D3D_OK) {
        Log::Error("NavGameWorldRenderer: unable to CreateVertexShader");
        return false;
    }
    if (device->CreatePixelShader(reinterpret_cast<const DWORD*>(&g_ps20_main), &pshader) != D3D_OK) {
        Log::Error("NavGameWorldRenderer: unable to CreateVertexShader");
        return false;
    }
    need_configure_pipeline = false;
    return true;
}

bool NavGameWorldRenderer::SetD3DTransform(IDirect3DDevice9* device, const NavmeshBuildSettings& nbs)
{
    // set up directX standard world/view/proj matrices according to those used to render the game world
    if (device == nullptr) {
        return false;
    }

    //constexpr auto vertex_shader_wvp_matrix_offset = 0u;
    //constexpr auto vertex_shader_view_matrix_offset = 4u;
    //constexpr auto vertex_shader_proj_matrix_offset = 8u;

    // compute world matrix:
    const auto scale_ = DirectX::XMMatrixScaling(nbs.scale, nbs.scale, nbs.scale);
    const auto rotate_ = DirectX::XMMatrixRotationX(-DirectX::XM_PIDIV2);
    //auto mat_world = scale_ * rotate_;
    //if (device->SetVertexShaderConstantF(vertex_shader_world_matrix_offset, reinterpret_cast<const float*>(&mat_world), 4) != D3D_OK) {
        //Log::Error("NavGameWorldRenderer: unable to SetVertexShaderConstantF(world), aborting render.");
        //return false;
    //}

    // compute view matrix:
    //DirectX::XMFLOAT4X4A mat_view{};
    const auto cam = GW::CameraMgr::GetCamera();
    const DirectX::XMFLOAT3 eye_pos = {cam->position.x, cam->position.y, cam->position.z};
    const DirectX::XMFLOAT3 player_pos = {cam->look_at_target.x, cam->look_at_target.y, cam->look_at_target.z};
    constexpr DirectX::XMFLOAT3 up = {0.0f, 0.0f, -1.0f};
    //XMStoreFloat4x4A(
        //&mat_view,
        //auto mat_view = XMMatrixTranspose(
            auto mat_view = DirectX::XMMatrixLookAtLH(XMLoadFloat3(&eye_pos), XMLoadFloat3(&player_pos), XMLoadFloat3(&up));
        //);
    //);
    //if (device->SetVertexShaderConstantF(vertex_shader_view_matrix_offset, reinterpret_cast<const float*>(&mat_view), 4) != D3D_OK) {
        //Log::Error("NavGameWorldRenderer: unable to SetVertexShaderConstantF(view), aborting render.");
        //return false;
    //}

    // compute projection matrix:
    //DirectX::XMFLOAT4X4A mat_proj{};
    const auto fov = GW::Render::GetFieldOfView();
    const auto aspect_ratio = static_cast<float>(GW::Render::GetViewportWidth()) / static_cast<float>(GW::Render::GetViewportHeight());

    //XMStoreFloat4x4A(
        //&mat_proj,
        //auto mat_proj = XMMatrixTranspose(
            auto mat_proj = DirectX::XMMatrixPerspectiveFovLH(fov, aspect_ratio, 0.1f, 1000000.0f);
        //);
    //);
    auto wvp = XMMatrixTranspose(scale_ * rotate_ * mat_view * mat_proj);
    //auto wvp = XMMatrixTranspose(mat_proj * mat_view *  rotate_ * scale_);
    if (device->SetVertexShaderConstantF(0, reinterpret_cast<const float*>(&wvp), 4) != D3D_OK) {
        Log::Error("NavGameWorldRenderer: unable to SetVertexShaderConstantF(projection), aborting render.");
        return false;
    }

    return true;
}
